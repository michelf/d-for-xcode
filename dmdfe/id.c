// File generated by idgen.c
#include "id.h"
#include "identifier.h"
#include "lexer.h"
Identifier *Id::IUnknown;
Identifier *Id::Object;
Identifier *Id::object;
Identifier *Id::max;
Identifier *Id::min;
Identifier *Id::This;
Identifier *Id::ctor;
Identifier *Id::dtor;
Identifier *Id::classInvariant;
Identifier *Id::unitTest;
Identifier *Id::staticCtor;
Identifier *Id::staticDtor;
Identifier *Id::init;
Identifier *Id::size;
Identifier *Id::__sizeof;
Identifier *Id::alignof;
Identifier *Id::mangleof;
Identifier *Id::stringof;
Identifier *Id::tupleof;
Identifier *Id::length;
Identifier *Id::remove;
Identifier *Id::ptr;
Identifier *Id::funcptr;
Identifier *Id::dollar;
Identifier *Id::offset;
Identifier *Id::offsetof;
Identifier *Id::ModuleInfo;
Identifier *Id::ClassInfo;
Identifier *Id::classinfo;
Identifier *Id::typeinfo;
Identifier *Id::outer;
Identifier *Id::Exception;
Identifier *Id::withSym;
Identifier *Id::result;
Identifier *Id::returnLabel;
Identifier *Id::delegate;
Identifier *Id::line;
Identifier *Id::empty;
Identifier *Id::p;
Identifier *Id::coverage;
Identifier *Id::TypeInfo;
Identifier *Id::TypeInfo_Class;
Identifier *Id::TypeInfo_Interface;
Identifier *Id::TypeInfo_Struct;
Identifier *Id::TypeInfo_Enum;
Identifier *Id::TypeInfo_Typedef;
Identifier *Id::TypeInfo_Pointer;
Identifier *Id::TypeInfo_Array;
Identifier *Id::TypeInfo_StaticArray;
Identifier *Id::TypeInfo_AssociativeArray;
Identifier *Id::TypeInfo_Function;
Identifier *Id::TypeInfo_Delegate;
Identifier *Id::TypeInfo_Tuple;
Identifier *Id::TypeInfo_Const;
Identifier *Id::TypeInfo_Invariant;
Identifier *Id::elements;
Identifier *Id::_arguments_typeinfo;
Identifier *Id::_arguments;
Identifier *Id::_argptr;
Identifier *Id::_match;
Identifier *Id::LINE;
Identifier *Id::FILE;
Identifier *Id::DATE;
Identifier *Id::TIME;
Identifier *Id::TIMESTAMP;
Identifier *Id::VENDOR;
Identifier *Id::VERSIONX;
Identifier *Id::nan;
Identifier *Id::infinity;
Identifier *Id::dig;
Identifier *Id::epsilon;
Identifier *Id::mant_dig;
Identifier *Id::max_10_exp;
Identifier *Id::max_exp;
Identifier *Id::min_10_exp;
Identifier *Id::min_exp;
Identifier *Id::re;
Identifier *Id::im;
Identifier *Id::C;
Identifier *Id::D;
Identifier *Id::Windows;
Identifier *Id::Pascal;
Identifier *Id::System;
Identifier *Id::exit;
Identifier *Id::success;
Identifier *Id::failure;
Identifier *Id::keys;
Identifier *Id::values;
Identifier *Id::rehash;
Identifier *Id::sort;
Identifier *Id::reverse;
Identifier *Id::dup;
Identifier *Id::idup;
Identifier *Id::___out;
Identifier *Id::___in;
Identifier *Id::__int;
Identifier *Id::__dollar;
Identifier *Id::__LOCAL_SIZE;
Identifier *Id::uadd;
Identifier *Id::neg;
Identifier *Id::com;
Identifier *Id::add;
Identifier *Id::add_r;
Identifier *Id::sub;
Identifier *Id::sub_r;
Identifier *Id::mul;
Identifier *Id::mul_r;
Identifier *Id::div;
Identifier *Id::div_r;
Identifier *Id::mod;
Identifier *Id::mod_r;
Identifier *Id::eq;
Identifier *Id::cmp;
Identifier *Id::iand;
Identifier *Id::iand_r;
Identifier *Id::ior;
Identifier *Id::ior_r;
Identifier *Id::ixor;
Identifier *Id::ixor_r;
Identifier *Id::shl;
Identifier *Id::shl_r;
Identifier *Id::shr;
Identifier *Id::shr_r;
Identifier *Id::ushr;
Identifier *Id::ushr_r;
Identifier *Id::cat;
Identifier *Id::cat_r;
Identifier *Id::assign;
Identifier *Id::addass;
Identifier *Id::subass;
Identifier *Id::mulass;
Identifier *Id::divass;
Identifier *Id::modass;
Identifier *Id::andass;
Identifier *Id::orass;
Identifier *Id::xorass;
Identifier *Id::shlass;
Identifier *Id::shrass;
Identifier *Id::ushrass;
Identifier *Id::catass;
Identifier *Id::postinc;
Identifier *Id::postdec;
Identifier *Id::index;
Identifier *Id::indexass;
Identifier *Id::slice;
Identifier *Id::sliceass;
Identifier *Id::call;
Identifier *Id::cast;
Identifier *Id::match;
Identifier *Id::next;
Identifier *Id::opIn;
Identifier *Id::opIn_r;
Identifier *Id::classNew;
Identifier *Id::classDelete;
Identifier *Id::apply;
Identifier *Id::applyReverse;
Identifier *Id::adDup;
Identifier *Id::adReverse;
Identifier *Id::aaLen;
Identifier *Id::aaKeys;
Identifier *Id::aaValues;
Identifier *Id::aaRehash;
Identifier *Id::lib;
Identifier *Id::msg;
Identifier *Id::GNU_asm;
Identifier *Id::tohash;
Identifier *Id::tostring;
Identifier *Id::alloca;
Identifier *Id::main;
Identifier *Id::WinMain;
Identifier *Id::DllMain;
void Id::initialize()
{
    IUnknown = Lexer::idPool("IUnknown");
    Object = Lexer::idPool("Object");
    object = Lexer::idPool("object");
    max = Lexer::idPool("max");
    min = Lexer::idPool("min");
    This = Lexer::idPool("this");
    ctor = Lexer::idPool("_ctor");
    dtor = Lexer::idPool("_dtor");
    classInvariant = Lexer::idPool("__invariant");
    unitTest = Lexer::idPool("_unitTest");
    staticCtor = Lexer::idPool("_staticCtor");
    staticDtor = Lexer::idPool("_staticDtor");
    init = Lexer::idPool("init");
    size = Lexer::idPool("size");
    __sizeof = Lexer::idPool("sizeof");
    alignof = Lexer::idPool("alignof");
    mangleof = Lexer::idPool("mangleof");
    stringof = Lexer::idPool("stringof");
    tupleof = Lexer::idPool("tupleof");
    length = Lexer::idPool("length");
    remove = Lexer::idPool("remove");
    ptr = Lexer::idPool("ptr");
    funcptr = Lexer::idPool("funcptr");
    dollar = Lexer::idPool("__dollar");
    offset = Lexer::idPool("offset");
    offsetof = Lexer::idPool("offsetof");
    ModuleInfo = Lexer::idPool("ModuleInfo");
    ClassInfo = Lexer::idPool("ClassInfo");
    classinfo = Lexer::idPool("classinfo");
    typeinfo = Lexer::idPool("typeinfo");
    outer = Lexer::idPool("outer");
    Exception = Lexer::idPool("Exception");
    withSym = Lexer::idPool("__withSym");
    result = Lexer::idPool("__result");
    returnLabel = Lexer::idPool("__returnLabel");
    delegate = Lexer::idPool("delegate");
    line = Lexer::idPool("line");
    empty = Lexer::idPool("");
    p = Lexer::idPool("p");
    coverage = Lexer::idPool("__coverage");
    TypeInfo = Lexer::idPool("TypeInfo");
    TypeInfo_Class = Lexer::idPool("TypeInfo_Class");
    TypeInfo_Interface = Lexer::idPool("TypeInfo_Interface");
    TypeInfo_Struct = Lexer::idPool("TypeInfo_Struct");
    TypeInfo_Enum = Lexer::idPool("TypeInfo_Enum");
    TypeInfo_Typedef = Lexer::idPool("TypeInfo_Typedef");
    TypeInfo_Pointer = Lexer::idPool("TypeInfo_Pointer");
    TypeInfo_Array = Lexer::idPool("TypeInfo_Array");
    TypeInfo_StaticArray = Lexer::idPool("TypeInfo_StaticArray");
    TypeInfo_AssociativeArray = Lexer::idPool("TypeInfo_AssociativeArray");
    TypeInfo_Function = Lexer::idPool("TypeInfo_Function");
    TypeInfo_Delegate = Lexer::idPool("TypeInfo_Delegate");
    TypeInfo_Tuple = Lexer::idPool("TypeInfo_Tuple");
    TypeInfo_Const = Lexer::idPool("TypeInfo_Const");
    TypeInfo_Invariant = Lexer::idPool("TypeInfo_Invariant");
    elements = Lexer::idPool("elements");
    _arguments_typeinfo = Lexer::idPool("_arguments_typeinfo");
    _arguments = Lexer::idPool("_arguments");
    _argptr = Lexer::idPool("_argptr");
    _match = Lexer::idPool("_match");
    LINE = Lexer::idPool("__LINE__");
    FILE = Lexer::idPool("__FILE__");
    DATE = Lexer::idPool("__DATE__");
    TIME = Lexer::idPool("__TIME__");
    TIMESTAMP = Lexer::idPool("__TIMESTAMP__");
    VENDOR = Lexer::idPool("__VENDOR__");
    VERSIONX = Lexer::idPool("__VERSION__");
    nan = Lexer::idPool("nan");
    infinity = Lexer::idPool("infinity");
    dig = Lexer::idPool("dig");
    epsilon = Lexer::idPool("epsilon");
    mant_dig = Lexer::idPool("mant_dig");
    max_10_exp = Lexer::idPool("max_10_exp");
    max_exp = Lexer::idPool("max_exp");
    min_10_exp = Lexer::idPool("min_10_exp");
    min_exp = Lexer::idPool("min_exp");
    re = Lexer::idPool("re");
    im = Lexer::idPool("im");
    C = Lexer::idPool("C");
    D = Lexer::idPool("D");
    Windows = Lexer::idPool("Windows");
    Pascal = Lexer::idPool("Pascal");
    System = Lexer::idPool("System");
    exit = Lexer::idPool("exit");
    success = Lexer::idPool("success");
    failure = Lexer::idPool("failure");
    keys = Lexer::idPool("keys");
    values = Lexer::idPool("values");
    rehash = Lexer::idPool("rehash");
    sort = Lexer::idPool("sort");
    reverse = Lexer::idPool("reverse");
    dup = Lexer::idPool("dup");
    idup = Lexer::idPool("idup");
    ___out = Lexer::idPool("out");
    ___in = Lexer::idPool("in");
    __int = Lexer::idPool("int");
    __dollar = Lexer::idPool("$");
    __LOCAL_SIZE = Lexer::idPool("__LOCAL_SIZE");
    uadd = Lexer::idPool("opPos");
    neg = Lexer::idPool("opNeg");
    com = Lexer::idPool("opCom");
    add = Lexer::idPool("opAdd");
    add_r = Lexer::idPool("opAdd_r");
    sub = Lexer::idPool("opSub");
    sub_r = Lexer::idPool("opSub_r");
    mul = Lexer::idPool("opMul");
    mul_r = Lexer::idPool("opMul_r");
    div = Lexer::idPool("opDiv");
    div_r = Lexer::idPool("opDiv_r");
    mod = Lexer::idPool("opMod");
    mod_r = Lexer::idPool("opMod_r");
    eq = Lexer::idPool("opEquals");
    cmp = Lexer::idPool("opCmp");
    iand = Lexer::idPool("opAnd");
    iand_r = Lexer::idPool("opAnd_r");
    ior = Lexer::idPool("opOr");
    ior_r = Lexer::idPool("opOr_r");
    ixor = Lexer::idPool("opXor");
    ixor_r = Lexer::idPool("opXor_r");
    shl = Lexer::idPool("opShl");
    shl_r = Lexer::idPool("opShl_r");
    shr = Lexer::idPool("opShr");
    shr_r = Lexer::idPool("opShr_r");
    ushr = Lexer::idPool("opUShr");
    ushr_r = Lexer::idPool("opUShr_r");
    cat = Lexer::idPool("opCat");
    cat_r = Lexer::idPool("opCat_r");
    assign = Lexer::idPool("opAssign");
    addass = Lexer::idPool("opAddAssign");
    subass = Lexer::idPool("opSubAssign");
    mulass = Lexer::idPool("opMulAssign");
    divass = Lexer::idPool("opDivAssign");
    modass = Lexer::idPool("opModAssign");
    andass = Lexer::idPool("opAndAssign");
    orass = Lexer::idPool("opOrAssign");
    xorass = Lexer::idPool("opXorAssign");
    shlass = Lexer::idPool("opShlAssign");
    shrass = Lexer::idPool("opShrAssign");
    ushrass = Lexer::idPool("opUShrAssign");
    catass = Lexer::idPool("opCatAssign");
    postinc = Lexer::idPool("opPostInc");
    postdec = Lexer::idPool("opPostDec");
    index = Lexer::idPool("opIndex");
    indexass = Lexer::idPool("opIndexAssign");
    slice = Lexer::idPool("opSlice");
    sliceass = Lexer::idPool("opSliceAssign");
    call = Lexer::idPool("opCall");
    cast = Lexer::idPool("opCast");
    match = Lexer::idPool("opMatch");
    next = Lexer::idPool("opNext");
    opIn = Lexer::idPool("opIn");
    opIn_r = Lexer::idPool("opIn_r");
    classNew = Lexer::idPool("new");
    classDelete = Lexer::idPool("delete");
    apply = Lexer::idPool("opApply");
    applyReverse = Lexer::idPool("opApplyReverse");
    adDup = Lexer::idPool("_adDupT");
    adReverse = Lexer::idPool("_adReverse");
    aaLen = Lexer::idPool("_aaLen");
    aaKeys = Lexer::idPool("_aaKeys");
    aaValues = Lexer::idPool("_aaValues");
    aaRehash = Lexer::idPool("_aaRehash");
    lib = Lexer::idPool("lib");
    msg = Lexer::idPool("msg");
    GNU_asm = Lexer::idPool("GNU_asm");
    tohash = Lexer::idPool("toHash");
    tostring = Lexer::idPool("toString");
    alloca = Lexer::idPool("alloca");
    main = Lexer::idPool("main");
    WinMain = Lexer::idPool("WinMain");
    DllMain = Lexer::idPool("DllMain");
}
